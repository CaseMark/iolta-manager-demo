/**
 * Export Utilities
 *
 * Core export functionality for PDF, DOCX, and TXT formats
 * following legal document standards.
 */

import { jsPDF } from 'jspdf';
import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  AlignmentType,
  convertInchesToTwip,
  BorderStyle,
  Table,
  TableRow,
  TableCell,
  WidthType,
  PageNumber,
  NumberFormat,
  Footer,
  Header,
} from 'docx';
import { saveAs } from 'file-saver';

// ============================================================================
// Constants (per skill spec)
// ============================================================================

const BRANDING_TEXT = 'Generated by case.dev';
const FONT_FAMILY = 'Times New Roman';
const LINE_WIDTH = 72;

// Margins in inches
const MARGIN_TOP = 1;
const MARGIN_BOTTOM = 1;
const MARGIN_LEFT = 1.25;
const MARGIN_RIGHT = 1;

// Points conversion (72 points = 1 inch)
const POINTS_PER_INCH = 72;
const MARGIN_TOP_PT = MARGIN_TOP * POINTS_PER_INCH;
const MARGIN_BOTTOM_PT = MARGIN_BOTTOM * POINTS_PER_INCH;
const MARGIN_LEFT_PT = MARGIN_LEFT * POINTS_PER_INCH;
const MARGIN_RIGHT_PT = MARGIN_RIGHT * POINTS_PER_INCH;

// Font sizes in points (per skill spec)
const FONT_SIZE_TITLE = 12;  // Titles: 12pt Bold
const FONT_SIZE_BODY = 12;   // Body: 12pt Normal
const FONT_SIZE_SMALL = 10;  // Tables/small text
const FONT_SIZE_FOOTER = 9;  // Headers/Footers: 9pt Italic
const LINE_HEIGHT = 1.15;    // Single or 1.15

// ============================================================================
// Types
// ============================================================================

export type ExportFormat = 'pdf' | 'docx' | 'txt';

export interface ExportOptions {
  format: ExportFormat;
  includeTimestamps?: boolean;
  headerText?: string;
  footerText?: string;
}

export interface ExportPreviewData {
  blobUrl: string;
  blob: Blob;
  fileName: string;
  format: ExportFormat;
  content?: string;       // TXT preview
  htmlPreview?: string;   // DOCX preview
}

export interface ReportSection {
  title: string;
  content: ReportContent[];
}

export interface ReportContent {
  type: 'text' | 'table' | 'summary';
  text?: string;
  label?: string;
  table?: ReportTableData;
  summary?: ReportSummaryItem[];
}

export interface ReportTableData {
  headers: string[];
  rows: string[][];
  alignRight?: number[];  // Column indices that should be right-aligned
  totalRow?: string[];    // Optional total row
}

export interface ReportSummaryItem {
  label: string;
  value: string;
}

export interface ReportData {
  title: string;
  subtitle: string;
  generatedDate: string;
  sections: ReportSection[];
}

// ============================================================================
// Utility Functions
// ============================================================================

export function formatDate(date: Date | string): string {
  const d = typeof date === 'string' ? new Date(date) : date;
  return d.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
}

export function sanitizeFilename(name: string): string {
  return name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
}

function generateFileName(title: string, format: ExportFormat): string {
  const timestamp = new Date().toISOString().slice(0, 10);
  return `${sanitizeFilename(title)}_${timestamp}.${format}`;
}

// ============================================================================
// PDF Export (jsPDF)
// ============================================================================

function generatePDF(data: ReportData): Blob {
  const doc = new jsPDF({
    unit: 'pt',
    format: 'letter',
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const contentWidth = pageWidth - MARGIN_LEFT_PT - MARGIN_RIGHT_PT;

  let y = MARGIN_TOP_PT;
  let pageNum = 1;

  const addPage = () => {
    doc.addPage();
    pageNum++;
    y = MARGIN_TOP_PT;
  };

  const checkPageBreak = (neededHeight: number) => {
    if (y + neededHeight > pageHeight - MARGIN_BOTTOM_PT - 30) {
      addPage();
      return true;
    }
    return false;
  };

  // Header
  doc.setFont(FONT_FAMILY, 'italic');
  doc.setFontSize(FONT_SIZE_FOOTER);
  doc.setTextColor(102, 102, 102);
  doc.text(BRANDING_TEXT, MARGIN_LEFT_PT, y);
  doc.text(data.generatedDate, pageWidth - MARGIN_RIGHT_PT, y, { align: 'right' });
  y += 20;

  // Divider
  doc.setDrawColor(204, 204, 204);
  doc.setLineWidth(0.5);
  doc.line(MARGIN_LEFT_PT, y, pageWidth - MARGIN_RIGHT_PT, y);
  y += 30;

  // Title
  doc.setFont(FONT_FAMILY, 'bold');
  doc.setFontSize(FONT_SIZE_TITLE);
  doc.setTextColor(0, 0, 0);
  doc.text(data.title.toUpperCase(), pageWidth / 2, y, { align: 'center' });
  y += 20;

  // Subtitle
  doc.setFont(FONT_FAMILY, 'normal');
  doc.setFontSize(FONT_SIZE_BODY);
  doc.text(data.subtitle, pageWidth / 2, y, { align: 'center' });
  y += 40;

  // Sections
  for (const section of data.sections) {
    checkPageBreak(60);

    // Section title
    doc.setFont(FONT_FAMILY, 'bold');
    doc.setFontSize(FONT_SIZE_BODY);
    doc.text(section.title.toUpperCase(), MARGIN_LEFT_PT, y);
    y += 5;
    doc.setLineWidth(0.5);
    doc.setDrawColor(0, 0, 0);
    doc.line(MARGIN_LEFT_PT, y, pageWidth - MARGIN_RIGHT_PT, y);
    y += 20;

    // Section content
    for (const content of section.content) {
      if (content.type === 'summary' && content.summary) {
        // Summary grid
        const itemWidth = contentWidth / content.summary.length;
        let x = MARGIN_LEFT_PT;

        for (const item of content.summary) {
          doc.setFont(FONT_FAMILY, 'normal');
          doc.setFontSize(FONT_SIZE_SMALL);
          doc.setTextColor(102, 102, 102);
          doc.text(item.label.toUpperCase(), x + itemWidth / 2, y, { align: 'center' });

          doc.setFont(FONT_FAMILY, 'bold');
          doc.setFontSize(FONT_SIZE_BODY);
          doc.setTextColor(0, 0, 0);
          doc.text(item.value, x + itemWidth / 2, y + 15, { align: 'center' });

          x += itemWidth;
        }
        y += 40;
      } else if (content.type === 'table' && content.table) {
        checkPageBreak(100);
        y = renderPDFTable(doc, content.table, y, MARGIN_LEFT_PT, contentWidth, pageHeight, MARGIN_BOTTOM_PT, addPage);
        y += 20;
      } else if (content.type === 'text' && content.text) {
        doc.setFont(FONT_FAMILY, content.label ? 'bold' : 'normal');
        doc.setFontSize(FONT_SIZE_BODY);
        doc.setTextColor(0, 0, 0);

        if (content.label) {
          doc.text(`${content.label}: `, MARGIN_LEFT_PT, y);
          const labelWidth = doc.getTextWidth(`${content.label}: `);
          doc.setFont(FONT_FAMILY, 'normal');
          const lines = doc.splitTextToSize(content.text, contentWidth - labelWidth);
          doc.text(lines[0], MARGIN_LEFT_PT + labelWidth, y);
          if (lines.length > 1) {
            y += 15;
            for (let i = 1; i < lines.length; i++) {
              checkPageBreak(15);
              doc.text(lines[i], MARGIN_LEFT_PT, y);
              y += 15;
            }
          }
        } else {
          const lines = doc.splitTextToSize(content.text, contentWidth);
          for (const line of lines) {
            checkPageBreak(15);
            doc.text(line, MARGIN_LEFT_PT, y);
            y += 15;
          }
        }
        y += 10;
      }
    }

    y += 20;
  }

  // End marker
  checkPageBreak(40);
  y += 20;
  doc.setFont(FONT_FAMILY, 'bold');
  doc.setFontSize(FONT_SIZE_BODY);
  doc.text('[END OF REPORT]', pageWidth / 2, y, { align: 'center' });

  // Footer divider
  y += 30;
  doc.setDrawColor(204, 204, 204);
  doc.line(MARGIN_LEFT_PT, y, pageWidth - MARGIN_RIGHT_PT, y);

  // Add page numbers to all pages
  const totalPages = doc.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    doc.setPage(i);
    doc.setFont(FONT_FAMILY, 'italic');
    doc.setFontSize(FONT_SIZE_FOOTER);
    doc.setTextColor(102, 102, 102);

    // Footer
    const footerY = pageHeight - MARGIN_BOTTOM_PT + 20;
    doc.text(BRANDING_TEXT, MARGIN_LEFT_PT, footerY);
    doc.text(`Generated: ${formatDate(new Date())}`, pageWidth - MARGIN_RIGHT_PT, footerY, { align: 'right' });
    doc.text(`Page ${i} of ${totalPages}`, pageWidth / 2, footerY + 15, { align: 'center' });
  }

  return doc.output('blob');
}

function renderPDFTable(
  doc: jsPDF,
  table: ReportTableData,
  startY: number,
  marginLeft: number,
  contentWidth: number,
  pageHeight: number,
  marginBottom: number,
  addPage: () => void
): number {
  let y = startY;
  const cellPadding = 8;
  const lineHeight = 14;
  const minRowHeight = 24;
  const alignRight = table.alignRight || [];

  // Calculate column widths based on header names and content
  const colWidths = calculateColumnWidths(doc, table, contentWidth, cellPadding);

  // Helper to get column start position
  const getColX = (colIndex: number): number => {
    let x = marginLeft;
    for (let i = 0; i < colIndex; i++) {
      x += colWidths[i];
    }
    return x;
  };

  // Helper to wrap text into multiple lines that fit the column width
  // For numeric columns (alignRight), never wrap - return single line
  const wrapText = (text: string, maxWidth: number, fontSize: number, colIndex: number): string[] => {
    doc.setFontSize(fontSize);
    const cleanText = text.replace(/\n/g, ' ').trim();

    // Numeric columns should never wrap
    if (alignRight.includes(colIndex)) {
      return [cleanText];
    }

    if (maxWidth <= 0) return [cleanText];
    const lines = doc.splitTextToSize(cleanText, maxWidth);
    return lines;
  };

  // Helper to render a cell with wrapped text
  const renderCell = (
    text: string,
    colIndex: number,
    colW: number,
    fontSize: number,
    maxLines: number
  ): string[] => {
    const availableWidth = colW - cellPadding * 2;
    let lines = wrapText(text, availableWidth, fontSize, colIndex);

    // Only try smaller font for text columns that have too many lines
    if (!alignRight.includes(colIndex) && lines.length > maxLines && fontSize > 8) {
      const smallerFont = Math.max(8, fontSize - 1);
      lines = wrapText(text, availableWidth, smallerFont, colIndex);
      doc.setFontSize(smallerFont);
    }

    return lines;
  };

  // Calculate row height based on wrapped content (only text columns can wrap)
  const calculateRowHeight = (row: string[], fontSize: number): number => {
    let maxLines = 1;
    row.forEach((cell, i) => {
      const availableWidth = colWidths[i] - cellPadding * 2;
      const lines = wrapText(cell, availableWidth, fontSize, i);
      maxLines = Math.max(maxLines, lines.length);
    });
    return Math.max(minRowHeight, maxLines * lineHeight + cellPadding);
  };

  // Header row
  doc.setFont(FONT_FAMILY, 'bold');
  doc.setFontSize(FONT_SIZE_SMALL);
  doc.setTextColor(0, 0, 0);

  const headerHeight = calculateRowHeight(table.headers, FONT_SIZE_SMALL);
  doc.setFillColor(245, 245, 245);
  doc.rect(marginLeft, y - cellPadding, contentWidth, headerHeight, 'F');

  table.headers.forEach((header, i) => {
    const colX = getColX(i);
    const colW = colWidths[i];
    const align = alignRight.includes(i) ? 'right' : 'left';
    const lines = renderCell(header, i, colW, FONT_SIZE_SMALL, 2);
    doc.setFontSize(FONT_SIZE_SMALL);
    doc.setFont(FONT_FAMILY, 'bold');

    lines.forEach((line, lineIdx) => {
      const textX = align === 'right' ? colX + colW - cellPadding : colX + cellPadding;
      doc.text(line, textX, y + lineIdx * lineHeight, { align });
    });
  });

  y += headerHeight - cellPadding;
  doc.setDrawColor(0, 0, 0);
  doc.setLineWidth(1);
  doc.line(marginLeft, y, marginLeft + contentWidth, y);
  y += lineHeight + 2;

  // Data rows
  doc.setFont(FONT_FAMILY, 'normal');
  doc.setLineWidth(0.5);

  for (const row of table.rows) {
    const rowHeight = calculateRowHeight(row, FONT_SIZE_SMALL);

    // Check for page break
    if (y + rowHeight > pageHeight - marginBottom - 30) {
      addPage();
      y = MARGIN_TOP_PT;
    }

    row.forEach((cell, i) => {
      const colX = getColX(i);
      const colW = colWidths[i];
      const align = alignRight.includes(i) ? 'right' : 'left';
      const lines = renderCell(cell, i, colW, FONT_SIZE_SMALL, 3);

      doc.setFontSize(FONT_SIZE_SMALL);
      doc.setFont(FONT_FAMILY, 'normal');

      lines.forEach((line, lineIdx) => {
        const textX = align === 'right' ? colX + colW - cellPadding : colX + cellPadding;
        doc.text(line, textX, y + lineIdx * lineHeight, { align });
      });
    });

    y += rowHeight - cellPadding;
    doc.setDrawColor(221, 221, 221);
    doc.line(marginLeft, y, marginLeft + contentWidth, y);
    y += cellPadding + 4;
  }

  // Total row
  if (table.totalRow) {
    const totalRowHeight = calculateRowHeight(table.totalRow, FONT_SIZE_SMALL);

    if (y + totalRowHeight > pageHeight - marginBottom - 30) {
      addPage();
      y = MARGIN_TOP_PT;
    }

    doc.setFillColor(249, 249, 249);
    doc.rect(marginLeft, y - cellPadding, contentWidth, totalRowHeight, 'F');
    doc.setFont(FONT_FAMILY, 'bold');
    doc.setFontSize(FONT_SIZE_SMALL);

    table.totalRow.forEach((cell, i) => {
      const colX = getColX(i);
      const colW = colWidths[i];
      const align = alignRight.includes(i) ? 'right' : 'left';
      const lines = renderCell(cell, i, colW, FONT_SIZE_SMALL, 2);
      doc.setFontSize(FONT_SIZE_SMALL);
      doc.setFont(FONT_FAMILY, 'bold');

      lines.forEach((line, lineIdx) => {
        const textX = align === 'right' ? colX + colW - cellPadding : colX + cellPadding;
        doc.text(line, textX, y + lineIdx * lineHeight, { align });
      });
    });

    y += totalRowHeight;
  }

  return y;
}

// Calculate smart column widths based on content
function calculateColumnWidths(
  doc: jsPDF,
  table: ReportTableData,
  totalWidth: number,
  padding: number
): number[] {
  const colCount = table.headers.length;
  const alignRight = table.alignRight || [];

  // Calculate required width for each column (header + max data width)
  doc.setFontSize(FONT_SIZE_SMALL);
  const requiredWidths = table.headers.map((header, i) => {
    const headerWidth = doc.getTextWidth(header) + padding * 2;
    const maxDataWidth = Math.max(
      ...table.rows.map(row => {
        const cellText = (row[i] || '').replace(/\n/g, ' ');
        return doc.getTextWidth(cellText) + padding * 2;
      }),
      0
    );
    const totalRowWidth = table.totalRow
      ? doc.getTextWidth(table.totalRow[i] || '') + padding * 2
      : 0;
    return Math.max(headerWidth, maxDataWidth, totalRowWidth);
  });

  // Columns that must NOT wrap (numeric/right-aligned columns)
  // These get their full required width
  const fixedWidths = requiredWidths.map((w, i) =>
    alignRight.includes(i) ? w + 10 : 0 // Add extra padding for numeric columns
  );

  // Calculate remaining width for flexible (text) columns
  const fixedTotal = fixedWidths.reduce((a, b) => a + b, 0);
  const remainingWidth = totalWidth - fixedTotal;

  // Count flexible columns and their required widths
  const flexibleIndices = table.headers.map((_, i) => i).filter(i => !alignRight.includes(i));
  const flexibleRequired = flexibleIndices.reduce((sum, i) => sum + requiredWidths[i], 0);

  // Distribute remaining width among flexible columns
  const finalWidths = requiredWidths.map((required, i) => {
    if (alignRight.includes(i)) {
      // Fixed width columns (numeric) - never wrap
      return fixedWidths[i];
    } else {
      // Flexible columns - distribute proportionally
      if (flexibleRequired > 0 && remainingWidth > 0) {
        const proportion = required / flexibleRequired;
        return Math.max(proportion * remainingWidth, 50); // Min 50pt for text columns
      }
      return Math.max(required, 50);
    }
  });

  // Ensure total equals totalWidth
  const finalTotal = finalWidths.reduce((a, b) => a + b, 0);
  if (Math.abs(finalTotal - totalWidth) > 1) {
    const scale = totalWidth / finalTotal;
    return finalWidths.map(w => w * scale);
  }

  return finalWidths;
}

// ============================================================================
// Word Export (docx)
// ============================================================================

async function generateDOCX(data: ReportData): Promise<Blob> {
  const children: Paragraph[] = [];

  // Title
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: data.title.toUpperCase(),
          bold: true,
          size: FONT_SIZE_TITLE * 2,
          font: FONT_FAMILY,
        }),
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 100 },
    })
  );

  // Subtitle
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: data.subtitle,
          size: FONT_SIZE_BODY * 2,
          font: FONT_FAMILY,
        }),
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 },
    })
  );

  // Sections
  for (const section of data.sections) {
    // Section title
    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: section.title.toUpperCase(),
            bold: true,
            size: FONT_SIZE_BODY * 2,
            font: FONT_FAMILY,
          }),
        ],
        border: {
          bottom: {
            color: '000000',
            space: 1,
            style: BorderStyle.SINGLE,
            size: 6,
          },
        },
        spacing: { before: 300, after: 200 },
      })
    );

    // Section content
    for (const content of section.content) {
      if (content.type === 'summary' && content.summary) {
        // Summary as table row
        const cells = content.summary.map(
          (item) =>
            new TableCell({
              children: [
                new Paragraph({
                  children: [
                    new TextRun({
                      text: item.label.toUpperCase(),
                      size: FONT_SIZE_SMALL * 2,
                      color: '666666',
                      font: FONT_FAMILY,
                    }),
                  ],
                  alignment: AlignmentType.CENTER,
                }),
                new Paragraph({
                  children: [
                    new TextRun({
                      text: item.value,
                      bold: true,
                      size: FONT_SIZE_BODY * 2,
                      font: FONT_FAMILY,
                    }),
                  ],
                  alignment: AlignmentType.CENTER,
                }),
              ],
              width: { size: 100 / content.summary!.length, type: WidthType.PERCENTAGE },
            })
        );

        children.push(
          new Paragraph({
            children: [],
            spacing: { before: 100 },
          })
        );

        const summaryTable = new Table({
          rows: [new TableRow({ children: cells })],
          width: { size: 100, type: WidthType.PERCENTAGE },
        });

        // @ts-expect-error - docx types are incomplete
        children.push(summaryTable);

        children.push(
          new Paragraph({
            children: [],
            spacing: { after: 200 },
          })
        );
      } else if (content.type === 'table' && content.table) {
        const tableRows: TableRow[] = [];

        // Header row
        tableRows.push(
          new TableRow({
            children: content.table.headers.map(
              (header, i) =>
                new TableCell({
                  children: [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: header,
                          bold: true,
                          size: FONT_SIZE_SMALL * 2,
                          font: FONT_FAMILY,
                        }),
                      ],
                      alignment: content.table!.alignRight?.includes(i)
                        ? AlignmentType.RIGHT
                        : AlignmentType.LEFT,
                    }),
                  ],
                  shading: { fill: 'F5F5F5' },
                })
            ),
            tableHeader: true,
          })
        );

        // Data rows
        for (const row of content.table.rows) {
          tableRows.push(
            new TableRow({
              children: row.map(
                (cell, i) =>
                  new TableCell({
                    children: [
                      new Paragraph({
                        children: [
                          new TextRun({
                            text: cell,
                            size: FONT_SIZE_SMALL * 2,
                            font: FONT_FAMILY,
                          }),
                        ],
                        alignment: content.table!.alignRight?.includes(i)
                          ? AlignmentType.RIGHT
                          : AlignmentType.LEFT,
                      }),
                    ],
                  })
              ),
            })
          );
        }

        // Total row
        if (content.table.totalRow) {
          tableRows.push(
            new TableRow({
              children: content.table.totalRow.map(
                (cell, i) =>
                  new TableCell({
                    children: [
                      new Paragraph({
                        children: [
                          new TextRun({
                            text: cell,
                            bold: true,
                            size: FONT_SIZE_SMALL * 2,
                            font: FONT_FAMILY,
                          }),
                        ],
                        alignment: content.table!.alignRight?.includes(i)
                          ? AlignmentType.RIGHT
                          : AlignmentType.LEFT,
                      }),
                    ],
                    shading: { fill: 'F9F9F9' },
                  })
              ),
            })
          );
        }

        const table = new Table({
          rows: tableRows,
          width: { size: 100, type: WidthType.PERCENTAGE },
        });

        // @ts-expect-error - docx types are incomplete
        children.push(table);

        children.push(
          new Paragraph({
            children: [],
            spacing: { after: 200 },
          })
        );
      } else if (content.type === 'text' && content.text) {
        const textRuns: TextRun[] = [];

        if (content.label) {
          textRuns.push(
            new TextRun({
              text: `${content.label}: `,
              bold: true,
              size: FONT_SIZE_BODY * 2,
              font: FONT_FAMILY,
            })
          );
        }

        textRuns.push(
          new TextRun({
            text: content.text,
            size: FONT_SIZE_BODY * 2,
            font: FONT_FAMILY,
          })
        );

        children.push(
          new Paragraph({
            children: textRuns,
            spacing: { after: 150, line: 276 },
          })
        );
      }
    }
  }

  // End marker
  children.push(
    new Paragraph({
      children: [
        new TextRun({
          text: '[END OF REPORT]',
          bold: true,
          size: FONT_SIZE_BODY * 2,
          font: FONT_FAMILY,
        }),
      ],
      alignment: AlignmentType.CENTER,
      spacing: { before: 400, after: 300 },
    })
  );

  const doc = new Document({
    sections: [
      {
        properties: {
          page: {
            margin: {
              top: convertInchesToTwip(MARGIN_TOP),
              bottom: convertInchesToTwip(MARGIN_BOTTOM),
              left: convertInchesToTwip(MARGIN_LEFT),
              right: convertInchesToTwip(MARGIN_RIGHT),
            },
          },
        },
        headers: {
          default: new Header({
            children: [
              new Paragraph({
                children: [
                  new TextRun({
                    text: BRANDING_TEXT,
                    italics: true,
                    size: FONT_SIZE_FOOTER * 2,
                    color: '666666',
                    font: FONT_FAMILY,
                  }),
                  new TextRun({ text: '\t' }),
                  new TextRun({
                    text: data.generatedDate,
                    italics: true,
                    size: FONT_SIZE_FOOTER * 2,
                    color: '666666',
                    font: FONT_FAMILY,
                  }),
                ],
                tabStops: [{ type: 'right' as const, position: convertInchesToTwip(6.25) }],
                border: {
                  bottom: {
                    color: 'CCCCCC',
                    space: 1,
                    style: BorderStyle.SINGLE,
                    size: 6,
                  },
                },
              }),
            ],
          }),
        },
        footers: {
          default: new Footer({
            children: [
              new Paragraph({
                children: [
                  new TextRun({
                    text: BRANDING_TEXT,
                    italics: true,
                    size: FONT_SIZE_FOOTER * 2,
                    color: '666666',
                    font: FONT_FAMILY,
                  }),
                  new TextRun({ text: '\t' }),
                  new TextRun({
                    text: `Generated: ${formatDate(new Date())}`,
                    italics: true,
                    size: FONT_SIZE_FOOTER * 2,
                    color: '666666',
                    font: FONT_FAMILY,
                  }),
                ],
                tabStops: [{ type: 'right' as const, position: convertInchesToTwip(6.25) }],
                border: {
                  top: {
                    color: 'CCCCCC',
                    space: 1,
                    style: BorderStyle.SINGLE,
                    size: 6,
                  },
                },
              }),
              new Paragraph({
                children: [
                  new TextRun({
                    children: ['Page ', PageNumber.CURRENT, ' of ', PageNumber.TOTAL_PAGES],
                    italics: true,
                    size: FONT_SIZE_FOOTER * 2,
                    color: '666666',
                    font: FONT_FAMILY,
                  }),
                ],
                alignment: AlignmentType.CENTER,
              }),
            ],
          }),
        },
        children,
      },
    ],
  });

  return await Packer.toBlob(doc);
}

// ============================================================================
// Plain Text Export
// ============================================================================

function generateTXT(data: ReportData): Blob {
  const divider = '─'.repeat(LINE_WIDTH);
  let content = '';

  // Header
  content += `${BRANDING_TEXT.padEnd(50)}${data.generatedDate}\n`;
  content += divider + '\n\n';

  // Title
  content += `${data.title.toUpperCase()}\n`;
  content += `${data.subtitle}\n\n`;

  // Sections
  for (const section of data.sections) {
    content += `${section.title.toUpperCase()}\n`;
    content += '─'.repeat(section.title.length) + '\n\n';

    for (const item of section.content) {
      if (item.type === 'summary' && item.summary) {
        for (const s of item.summary) {
          content += `${s.label}: ${s.value}\n`;
        }
        content += '\n';
      } else if (item.type === 'table' && item.table) {
        // Calculate column widths
        const colWidths = item.table.headers.map((h, i) => {
          const maxDataWidth = Math.max(...item.table!.rows.map((r) => r[i]?.length || 0));
          return Math.max(h.length, maxDataWidth, 10);
        });

        // Header row
        content += item.table.headers.map((h, i) => h.padEnd(colWidths[i])).join(' | ') + '\n';
        content += colWidths.map((w) => '─'.repeat(w)).join('─┼─') + '\n';

        // Data rows
        for (const row of item.table.rows) {
          content += row.map((cell, i) => {
            const padFn = item.table!.alignRight?.includes(i) ? 'padStart' : 'padEnd';
            return cell[padFn](colWidths[i]);
          }).join(' | ') + '\n';
        }

        // Total row
        if (item.table.totalRow) {
          content += colWidths.map((w) => '─'.repeat(w)).join('─┼─') + '\n';
          content += item.table.totalRow.map((cell, i) => {
            const padFn = item.table!.alignRight?.includes(i) ? 'padStart' : 'padEnd';
            return cell[padFn](colWidths[i]);
          }).join(' | ') + '\n';
        }

        content += '\n';
      } else if (item.type === 'text' && item.text) {
        if (item.label) {
          content += `${item.label}: ${item.text}\n`;
        } else {
          content += `${item.text}\n`;
        }
      }
    }

    content += '\n';
  }

  // End marker
  content += '\n' + divider + '\n';
  content += '                         [END OF REPORT]\n';
  content += divider + '\n';

  // Footer
  content += `${BRANDING_TEXT.padEnd(50)}Generated: ${formatDate(new Date())}\n`;

  return new Blob([content], { type: 'text/plain;charset=utf-8' });
}

// ============================================================================
// Public API
// ============================================================================

export async function generateExportPreview(
  data: ReportData,
  options: ExportOptions
): Promise<ExportPreviewData> {
  const fileName = generateFileName(data.title, options.format);
  let blob: Blob;
  let content: string | undefined;
  let htmlPreview: string | undefined;

  switch (options.format) {
    case 'pdf':
      blob = generatePDF(data);
      break;
    case 'docx':
      blob = await generateDOCX(data);
      htmlPreview = generateHTMLPreview(data);
      break;
    case 'txt':
      blob = generateTXT(data);
      content = await blob.text();
      break;
    default:
      throw new Error(`Unsupported format: ${options.format}`);
  }

  const blobUrl = URL.createObjectURL(blob);

  return {
    blobUrl,
    blob,
    fileName,
    format: options.format,
    content,
    htmlPreview,
  };
}

export async function exportReport(data: ReportData, options: ExportOptions): Promise<void> {
  const preview = await generateExportPreview(data, options);
  downloadFromPreview(preview);
}

export function downloadFromPreview(preview: ExportPreviewData): void {
  saveAs(preview.blob, preview.fileName);
}

export function revokePreviewUrl(preview: ExportPreviewData): void {
  URL.revokeObjectURL(preview.blobUrl);
}

// Generate HTML preview for DOCX (mirrors document structure)
// Uses case.dev color palette with orange accent
function generateHTMLPreview(data: ReportData): string {
  // case.dev color palette with warm background and orange accent
  const colors = {
    background: '#f8f7f5',      // warm light background (--background: 40 6% 97%)
    cardBg: '#ffffff',          // white card (--card: 0 0% 100%)
    foreground: '#1f1c19',      // warm dark text (--foreground: 20 10% 12%)
    muted: '#746b61',           // warm gray (--muted-foreground: 20 5% 45%)
    border: '#e0d9d1',          // warm border (--border: 30 10% 88%)
    primary: '#ff6b00',         // case.dev orange (--primary: 24 100% 50%)
    accent: '#ff6b00',          // case.dev orange accent
    headerBg: '#faf9f8',        // warm header background
  };

  let html = `
    <div style="font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-size: 14px; line-height: 1.6; padding: 60px 80px; margin: 0 auto; background: ${colors.cardBg}; color: ${colors.foreground};">
      <div style="text-align: center; border-bottom: 2px solid ${colors.border}; padding-bottom: 32px; margin-bottom: 48px;">
        <div style="font-size: 12px; color: ${colors.accent}; margin-bottom: 16px; letter-spacing: 0.5px; font-weight: 600; text-transform: uppercase;">${BRANDING_TEXT}</div>
        <div style="font-family: 'Spectral', Georgia, serif; font-size: 28px; font-weight: 600; text-transform: uppercase; letter-spacing: 2px; color: ${colors.foreground};">${data.title}</div>
        <div style="font-size: 18px; margin-top: 12px; color: ${colors.foreground};">${data.subtitle}</div>
        <div style="font-size: 13px; color: ${colors.muted}; margin-top: 16px;">Generated: ${data.generatedDate}</div>
      </div>
  `;

  for (const section of data.sections) {
    html += `
      <div style="margin-bottom: 48px;">
        <div style="font-family: 'Spectral', Georgia, serif; font-size: 16px; font-weight: 600; text-transform: uppercase; border-bottom: 1px solid ${colors.foreground}; padding-bottom: 8px; margin-bottom: 24px; letter-spacing: 1px; color: ${colors.foreground};">${section.title}</div>
    `;

    for (const content of section.content) {
      if (content.type === 'summary' && content.summary) {
        // Summary cards - use CSS grid for equal distribution, prevent word breaks
        html += `<div style="display: grid; grid-template-columns: repeat(${content.summary.length}, 1fr); gap: 24px; margin-bottom: 32px; padding: 24px; border: 1px solid ${colors.border}; background: ${colors.headerBg}; border-radius: 6px;">`;
        for (const item of content.summary) {
          html += `
            <div style="text-align: center; min-width: 0;">
              <div style="font-size: 11px; color: ${colors.muted}; text-transform: uppercase; margin-bottom: 8px; letter-spacing: 0.5px; word-wrap: break-word; overflow-wrap: break-word; hyphens: none;">${item.label}</div>
              <div style="font-size: 20px; font-weight: 700; color: ${colors.foreground}; white-space: nowrap;">${item.value}</div>
            </div>
          `;
        }
        html += '</div>';
      } else if (content.type === 'table' && content.table) {
        // Calculate column width percentages based on header type
        const colWidths = getHTMLColumnWidths(content.table.headers, content.table.alignRight || []);

        html += `<div style="margin-bottom: 32px; overflow-x: auto;">`;
        html += `<table style="width: 100%; border-collapse: collapse; font-size: 13px;">`;
        html += '<thead><tr>';
        for (let i = 0; i < content.table.headers.length; i++) {
          const align = content.table.alignRight?.includes(i) ? 'right' : 'left';
          const width = colWidths[i];
          html += `<th style="text-align: ${align}; padding: 12px 16px; border-bottom: 2px solid ${colors.foreground}; background: ${colors.headerBg}; font-weight: 600; width: ${width}%; vertical-align: bottom; white-space: nowrap;">${content.table.headers[i]}</th>`;
        }
        html += '</tr></thead><tbody>';
        for (const row of content.table.rows) {
          html += `<tr style="border-bottom: 1px solid ${colors.border};">`;
          for (let i = 0; i < row.length; i++) {
            const align = content.table.alignRight?.includes(i) ? 'right' : 'left';
            const isAmount = content.table.alignRight?.includes(i);
            // Replace newlines with line breaks for proper display
            const cellContent = row[i].replace(/\n/g, '<br>');
            html += `<td style="text-align: ${align}; padding: 12px 16px; vertical-align: top; color: ${colors.foreground};${isAmount ? ' white-space: nowrap; font-variant-numeric: tabular-nums;' : ' word-wrap: break-word; overflow-wrap: break-word;'}">${cellContent}</td>`;
          }
          html += '</tr>';
        }
        if (content.table.totalRow) {
          html += `<tr style="font-weight: 600; background: ${colors.headerBg};">`;
          for (let i = 0; i < content.table.totalRow.length; i++) {
            const align = content.table.alignRight?.includes(i) ? 'right' : 'left';
            const isAmount = content.table.alignRight?.includes(i);
            html += `<td style="text-align: ${align}; padding: 14px 16px; border-top: 2px solid ${colors.foreground};${isAmount ? ' font-variant-numeric: tabular-nums;' : ''}">${content.table.totalRow[i]}</td>`;
          }
          html += '</tr>';
        }
        html += '</tbody></table>';
        html += '</div>';
      } else if (content.type === 'text' && content.text) {
        if (content.label) {
          html += `<p style="margin-bottom: 16px; font-size: 14px; color: ${colors.foreground};"><strong>${content.label}:</strong> ${content.text}</p>`;
        } else {
          html += `<p style="margin-bottom: 16px; font-size: 14px; color: ${colors.muted};">${content.text}</p>`;
        }
      }
    }

    html += '</div>';
  }

  html += `
      <div style="text-align: center; margin-top: 56px; font-weight: 600; font-size: 14px; color: ${colors.foreground};">[END OF REPORT]</div>
      <div style="margin-top: 56px; padding-top: 24px; border-top: 1px solid ${colors.border}; font-size: 12px; color: ${colors.muted}; text-align: center;">
        <p style="margin: 6px 0;">This document is confidential and intended for authorized use only.</p>
        <p style="margin: 6px 0; color: ${colors.accent}; font-weight: 500;">${BRANDING_TEXT}</p>
      </div>
    </div>
  `;

  return html;
}

// Calculate column widths for HTML tables based on header names
function getHTMLColumnWidths(headers: string[], alignRight: number[]): number[] {
  const colCount = headers.length;

  // Define width percentages based on column type
  const widthMap: Record<string, number> = {
    'Date': 12,
    'Matter': 22,
    'Client': 18,
    'Description': 25,
    'Type': 10,
    'Amount': 13,
    'Balance': 13,
    'Status': 10,
    'Reference': 12,
    'Debit': 12,
    'Credit': 12,
    'Item': 60,
    'Holds': 12,
    'Available': 13,
    'Trust Balance': 14,
  };

  // Get widths for each column
  const widths = headers.map((header, i) => {
    // Check if it's a known header
    if (widthMap[header]) {
      return widthMap[header];
    }
    // If it's right-aligned (numeric), give it less space
    if (alignRight.includes(i)) {
      return 12;
    }
    // Default width for text columns
    return Math.floor(100 / colCount);
  });

  // Normalize to 100%
  const total = widths.reduce((a, b) => a + b, 0);
  if (total !== 100) {
    const scale = 100 / total;
    return widths.map(w => Math.round(w * scale));
  }

  return widths;
}
